<html>
<body></body>

<style>
text {
    fill: black;
}
.link {
    stroke:rgb(250,120,120);
    stroke-width:2;
    fill: none;
}
svg {
    background-color: gainsboro;
}
rect {
    opacity: 0.2;
}
</style>
<script type="text/javascript" src="dist/d3TidyTree.js"></script>
<script type="text/javascript" src="testData.js"></script>
<body>

<b>Data</b> 
<select id="selData" onchange='loadData(this.value)'>
    <option value='0'>sample</option>
    <option value='1'>flare</option>
    <option value='2'>test01</option>
    <option value='3'>test02</option>
    <option value='4'>test03</option>
    <option value='5'>test04</option>
    <option value='6'>test05</option>
    <option value='7'>test06</option>
</select>

<b>View</b> 
<select id="selView" onchange='drawTree()'>
    <option value='tree' selected>Tree</option>
    <option value='mindmap'>MindMap</option>
</select>

<b>Path</b> 
<select id="selPath" onchange='drawTree()'>
    <option value='curved'>Curved</option>
    <option value='straight' selected>Straight</option>
    <option value='angled'>Angled</option>
</select>

<b>Compress Tree</b> <input type="checkbox" id="compress" checked onchange="drawTree()"/>
<b>Flip Tree</b> <input type="checkbox" id="flip" onchange="drawTree()"/>
<b>Parent-Child Spacing</b> <input type="number" id="spacing" onchange="drawTree()" value="100"/>

<div id="container"></div>


<script type="text/javascript">
var d3 = lib.d3;
var layout = new lib.Layout();

; // new d3TidyTree.Layout();
var defaultFont = 'times';
var pathType = 'curved';

function loadData(sel) {
    data = dataSamples[sel];
    drawTree();
}

function drawTree() {

    d3.select("svg").remove();
    // clear some values
    rootx = undefined;
    rootx = undefined;

    root = d3.hierarchy(data);
    var descendants = root.descendants();

    computeNodeSizes(descendants, d3.select("#container").append("svg"));
    d3.select("svg").remove();

    layout.viewType = document.querySelector('#selView').value;
    pathType = document.querySelector('#selPath').value;

    layout.direction = document.querySelector('#flip').checked ? -1 : 1;
    layout.compressTree = document.querySelector('#compress').checked;
    layout.parentChildSeparation = + document.querySelector('#spacing').value;
    layout.run(root);

    var r = lib.Util.computeBounds(descendants);
    width = r.width + 400;
    height = r.height + 200;

    svg = d3.select("#container").append("svg")
    .attr("width", width)
    .attr("height", height)
    .append("g")
    .attr("class","root");

    centerRoot(root);
    update(root);
}

var sample = {
    name: "root",
    children: [
        { name:"node1" },
        { name:"node2 abc 123 abc 456",
            children: [
                { name: "node2-1" },
                { name: "node2-2" },
           ]
        },
        { name:"node3", pathType: 'angled',
            children: [
                { name: "node3-1 ----- xx" },
                { name: "node3-2 ----- xx",

                    children: [
                        { name: "node3-1" },
                        { name: "node3-2" },
                    ]

                 },
           ]
        },
        { name: "node4",
            pathType: 'straight',
            children: [
                { name: "node3-1" },
                { name: "node3-2" },
            ]

         }
    ]
};

var dataSamples = [ 
    sample,
    testData.flare,
    testData.test01,
    testData.test02,
    testData.test03,
    testData.test04,
    testData.test05,
    testData.test06
];

var data = sample;

function computeNodeSizes(descendants, svg) {

    svg.append('g')
        .selectAll('.dummyText')
        .data(descendants)
        .enter()
        .append('text')
        .attr('font-family', function(d) {
            return d.data.font || defaultFont;
        })
        .attr('dy', '.35em')
        .text(function(d) { return d.data.name })
        .each(function(d,i) {
            d.width = this.getComputedTextLength() + 8;
            d.height = this.getBBox().height + 8;
            this.remove() 
        })

    for (var i in descendants) {
        var d = descendants[i];
        if (d.data.name != undefined)
            continue;
        if (d.data.x_size != undefined && d.data.y_size != undefined) {
            d.width = d.data.y_size * 8;
            d.height = d.data.x_size * 8;
            continue;
        }
    }
}

var svg;
var rootx;
var rooty;
var width;
var height;

function centerRoot(root)
{
    var r = lib.Util.computeBounds(root.descendants());
    var xx = width / 2 - r.width / 2;
    var yy = height / 2 - r.height / 2;

    if (r.x < 0)
        xx += -r.x;
    if (r.y < 0)
        yy += -r.y;

    if (rootx == undefined) {
        rootx = xx;
        rooty = yy;
    } else {
        // peg root to its original x,y
        xx = rootx;
        yy = rooty;
    }

    d3.select("g.root")
        .attr("transform", `translate(${xx},${yy})`);
}

loadData(0);

function getLinkEndPoints(d) {
    var startX = d.source.x;
    
    startX += d.source.x > d.target.x ? -d.source.width : d.source.width;
    if (!d.source.parent) {
        if (d.source.viewType == 'mindmap' && d.source.x > d.target.x) {
            startX += d.source.width;
        }
    }

    var endX = d.target.x;
    var startY =  d.source.y + d.source.height/2;
    var endY = d.target.y + d.target.height/2;
    return { startX:startX, startY:startY, endX: endX, endY: endY };
}

function curvedPath(d) {
    var p = getLinkEndPoints(d);
    var w = Math.abs(p.startX - p.endX);
    if (d.source.x > d.target.x) {
        w *= -1;
    }

    var s = 1.5;
    // we draw left to right
    d.path = 'M' + p.startX + ',' + p.startY + ' ' +
        'C' + (p.startX + w / s) + ',' + p.startY + ' ' +
        (p.endX - w / s) + ',' + p.endY + ' ' +
        p.endX + ',' + p.endY;
    return d.path;
}

function angledPath(d) {
    var p = getLinkEndPoints(d);
    var w = Math.abs(p.startX - p.endX);
    if (d.source.x > d.target.x) {
        w *= -1;
    }

    var s = 2;
    // we draw left to right
    d.path = 'M' + p.startX + ',' + p.startY + ' ' +
        'L' + (p.startX + w / s) + ',' + p.startY + ' L' +
        (p.endX - w / s) + ',' + p.endY + ' L' +
        p.endX + ',' + p.endY;
    return d.path;
}


function straightPath(d) {
    var p = getLinkEndPoints(d);

    // we draw left to right
    d.path = 'M' + p.startX + ',' + p.startY + ' ' +
        'L' + p.endX + ',' + p.endY;
    return d.path;
}

// pass on path 'd'
function makePath(d) {
    var pt = d.source.data.pathType || pathType;
    if (pt == 'curved')
        return curvedPath(d);
    if (pt == 'angled')
        return angledPath(d);
    return straightPath(d);
}

// pass nodes select
function makeNode(g) {

}

function update(root) {
    var i = 0;
    var nodes = root.descendants();
    var gnodes = svg.selectAll('g.node')
            .data(nodes, function(d, i) { if (!d.id) d.id = 'node_' + (i); return d.id; })

    var links = root.links();
    var glinks = svg.selectAll('path.link')
           .data(links, function(d) { if (!d.id) d.id = 'link_' + d.source.id + '-' + d.target.id; return d.id; })

    var glinksenter = glinks.enter()
    
    // update
    glinks
        .transition()
        .attr('d', makePath);

    /*
        .attr("x1", function(d) {
            var offX = d.source.x > d.target.x ? -d.source.width : d.source.width;
            if (!d.source.parent && offX < 0)
                offX = 0;
            return d.source.x + offX;
        })
        .transition()
        .attr("y1", function(d) {
            return d.source.y + d.source.height/2;
        })
        .attr("x2", function(d) {
            return d.target.x;
        })
        .attr("y2", function(d) {
            return d.target.y + d.target.height/2;
        });
    */

    glinksenter
        .append('path')
        .attr('class', 'link')
        .attr('d', makePath)
        .style('opacity', 0)
        .transition()
        .style('opacity', 1)

        /*
        .attr("x1", function(d) {
            var offX = d.source.x > d.target.x ? -d.source.width : d.source.width;
            if (!d.source.parent && offX < 0)
                offX = 0;
            return d.source.x + offX;
        })
        .attr("y1", function(d) {
            return d.source.y + d.source.height/2;
        })
        .attr("x2", function(d) {
            return d.source.x;
        })
        .attr("y2", function(d) {
            return d.source.y;
        })
        .style('opacity', 0)
        .transition()
        .attr("x2", function(d) {
            return d.target.x;
        })
        .attr("y2", function(d) {
            return d.target.y + d.target.height/2;
        })
        .style('opacity', 1)
        */


    var genter = gnodes.enter()
    
    // update
    gnodes
        .transition()
        .attr('transform', function(d) {
                return `translate(${d.x},${d.y})`;
            })

    gnodes
        .select('text')
            .attr('y', function(d) { return d.height / 2; })
            .attr('text-anchor', function(d) { return d.direction == -1 ? 'end' : 'start' ; })

    gnodes
        .select('circle')
            .attr('fill', function(d) {
                if (d._children != undefined) {
                    return 'blue';
                }
                return 'lightsteelblue';
            })
            .attr('opacity', 1)
            .attr('display', function(d) {
                if (d.children == undefined && d._children == undefined)
                    return 'none';
                return '';
            })

    var g = genter
            .append('g')
            .attr("class", "node")

        g            
            .style('opacity', 0)
            .attr('transform', function(d) {
                var x = d.parent ? d.parent.x : d.x;
                var y = d.parent ? d.parent.y : d.y;
                return `translate(${x},${y})`;
            })
            .transition()
            .style('opacity', 1)
            .attr('transform', function(d) {
                return `translate(${d.x},${d.y})`;
            });

        g        
            .append('rect')
            .attr('x', function(d) {
                return d.direction == -1 ? -d.width : 0;
            })
            .attr('y', function(d) {
                return 0;
            })
            .attr('width', function(d) {
                return d.width;
            })
            .attr('height', function(d) {
                return d.height - 2;
            })
            .attr('fill', 'grey');

        g
            .append('text')
            .attr('font-family', function(d) {
                return d.data.font || defaultFont;
            })
            .attr('dy', '.35em')
            .attr('y', function(d) { return d.height / 2; })
            .attr('text-anchor', function(d) { return d.direction == -1 ? 'end' : 'start' ; })
            .text(function(d) {
                return d.data.name;
            });

        g        
            .append('circle')
            .attr('r', 8)
            .attr('opacity', 1)
            .attr('display', function(d) {
                if (d.children == undefined && d._children == undefined)
                    return 'none';
                return '';
            })
            .attr('fill', function(d) {
                if (d._children != undefined) {
                    return 'blue';
                }
                return 'lightsteelblue';
            })

        g.on('click', click);


    function refresh() {
        layout.run(root);

        update(root);
        centerRoot(root);
    }

    // Toggle children on click.
    function click(d) {
        if (!d.parent) {
            var didCollapse = false;
            d.children.map( c => { 
                if (c.children) {
                    c._children = c.children;
                    c.children = undefined; 
                    didCollapse = true;
                }
            })
            if (!didCollapse) {
                d.children.map( c => { 
                    if (c._children) {
                        c.children = c._children;
                        c._children = undefined; 
                    }
                })
            }
            refresh();
            return;
        }
        if (d.children) {
            d._children = d.children;
            d.children = undefined;
        } else {
            d.children = d._children;
            d._children = undefined;
        }
        refresh();
    }

    gnodes.exit()
        .style('opacity', 0.5)
        .transition()
        .style('opacity', 0)
        .attr('transform', function(d) {
                var x = d.parent ? d.parent.x : d.x;
                var y = d.parent ? d.parent.y : d.y;
                return `translate(${x},${y})`;
            })
        .remove();

    glinks.exit()
        .style('opacity', 0.5)
        .transition()
        .style('opacity', 0)
        // .attr('d', function(d) {
        //     var x = d.source.x;
        //     var y = d.source.y + d.source.height/2;
        //     return `M${x},${y} L${x},${y} L${x},${y} L${x},${y}`;
        // })
        .remove();
}

</script>

</body>
</html>